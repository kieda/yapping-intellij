//
{
    parserClass="io.hostilerobot.yapping.parser.YappingParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="Yapping"
    psiImplClassSuffix="Impl"
    psiPackage="io.hostilerobot.yapping.parser.psi"
    psiImplPackage="io.hostilerobot.yapping.parser.psi.impl"

    elementTypeHolderClass="io.hostilerobot.yapping.parser.YappingTypes"
    elementTypeClass="io.hostilerobot.yapping.token.YappingElementType"
    tokenTypeClass="io.hostilerobot.yapping.token.YappingTokenType"
}

/**
 * yapping may have items that consist of a header, then a set of properties
 * # example
 *   headerItem
 *   headerItem2
 *   123
 *   properties:
 *   properties2:
 *  // goes to the end of file
 */
//yapping ::= item* Properties? {rightAssociative=true}
yapping ::= yapping_?
yapping_ ::= Properties|(item yapping_?)
//items ::= (SectionData (COMMENT|WHITESPACE)+)*
item ::=
    SectionData
    |COMMENT|WHITESPACE // whitespace

SectionData ::= Pair|TransitionLExpr|TransitionRExpr|BaseData

BaseData ::=
    yPath1|jPath|fPath // paths. final path is a two part or more yapping segment
    |ySegmentMulti  // single yapping segment (not a path)
    |Precedence // (x)
    |Map|List   // composite data
    |REAL|QUOTIENT|INTEGER  // primitive - numbers
    |REGEX|LITERAL|YNAME // primitive - string types
// # Java Paths and Scopes
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
    jPath ::= (JPATH_START spacing jScope)
    jScope ::= jScopeSegment (spacing DOT spacing jScope)?
    jScopeSegment ::= (jSegmentMulti|jSegmentSingle)
    // single item in the segment
    jSegmentSingle ::= JNAME | containedSegment
    // multiple items in the segment
    jSegmentMulti ::=
        (JNAME jSegmentExclJBody)
        | (containedSegment jSegmentInclJBody)
    // jBody or jName cannot show up twice in a row
    jSegmentInclJBody ::= (JBODY jSegmentExclJBody?)
            | jSegmentExclJBody
    jSegmentExclJBody ::= containedSegment jSegmentInclJBody?

// # file paths and scopes
    fPath ::= (FPATH_START spacing fScope)
    fScope ::= fScopeSegment (spacing SLASH spacing fScope)?
    fScopeSegment ::= fSegmentMulti | fSegmentSingle
    fSegmentSingle ::= FNAME | containedSegment
    fSegmentMulti ::= (containedSegment fSegmentInclFName)
        | (FNAME fSegmentExclFName)
    fSegmentExclFName ::= containedSegment fSegmentInclFName?
    fSegmentInclFName ::= (FNAME (fSegmentExclFName?))
        | fSegmentExclFName

// # yapping paths and scopes
    //yPath0 ::= yPath1|NATURAL|ySegmentExclNat // single a or a(.b)+
    yPath1 ::= ((NATURAL spacing DOT spacing ySegmentExclNat) (spacing DOT spacing yPathRest)?)
        | (ySegmentExclNat spacing DOT spacing yPathRest)

    // fun idea -- ipaddress: 127.0.0.1 693.5.9.3; -- note that 0.0 would represent a double otherwise
    ySegmentExclNat ::= ySegmentMulti | containedSegment | YNAME  // multi segments are not considered nats

    yPathRest ::= (ySegmentMulti|containedSegment|YNAME|NATURAL) (spacing DOT spacing yPathRest)?
    ySegmentMulti ::= (containedSegment ySegmentInclVals)
        | ((YNAME|NATURAL) ySegmentExclVals)

    // (55).`~*5` vs 55.`~*5`
    // x.0abc x.0`[1-3]` x.0"123"
    // NATURAL -> containedSegment
    // (yBody|yName) -> containedSegment
    // containedSegment -> YBODY|NATURAL|containedSegment
    ySegmentExclVals ::= containedSegment ySegmentInclVals?
    ySegmentInclVals ::= ((NATURAL|YBODY) ySegmentExclVals?)
        | ySegmentExclVals

    // disallow NATURAL.NATURAL
    // -1.0.123

// possible -
/// connect any number of paths using "asdf"+(123, 456).0+"abc"
// current -
// connect paths by not having whitespace
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */

QUOTIENT ::= (INTEGER spacing AND spacing)? INTEGER spacing SLASH spacing NATURAL // 1 & 3/4, -1 &3/4, +1 & -3/4.
INTEGER ::= (SIGN spacing)? NATURAL
REAL ::= (SIGN spacing)? DECIMAL
DECIMAL ::= NATURAL DOT NATURAL // define DECIMAL in parser rather than lexer, as this might be part of a ysegment rather than a decimal
SIGN ::= (PLUS|MINUS)

// properties is just
//     name1 : value1a value1b
//     name2 : value2a value2b value2c
// to nest properties, we use precedence
//     name1 : value1a value1b
//     (name2 : value2a value2b) value2c
Properties ::= BaseData spacing PROPERTY_SEP (yapping_)?
//Section ::= BaseData spacing PROPERTY_SEP item* {pin=3}

Map ::= (MAP_START spacing MAP_END) // {}
    // { a = b[, c = d]* }
    | (MAP_START spacing PairBounded (spacing LIST_SEP spacing PairBounded)* spacing MAP_END)
List ::= (LIST_START LIST_END) // []
    // [a[, b]*]
    | LIST_START spacing BoundedData (spacing LIST_SEP spacing BoundedData)* spacing LIST_END
Precedence ::= PRECEDENCE_START spacing BoundedData spacing PRECEDENCE_END

Pair ::= PairExpr|TransitionLExpr|TransitionRExpr|BaseData
PairExpr ::= (TransitionLExpr|TransitionRExpr|BaseData) spacing PAIR_SEP spacing Pair {rightAssociative=true}
TransitionLExpr ::= (TransitionRExpr|BaseData) spacing TRANSITION_SEP_L spacing Pair {rightAssociative=true}
TransitionRExpr ::= BaseData spacing TRANSITION_SEP_R spacing Pair {rightAssociative=true}


BoundedData ::= PairBounded|TransitionLBounded|TransitionRBounded|Properties|BaseData
PairBounded ::= (TransitionLExpr|TransitionRExpr|BaseData) spacing PAIR_SEP spacing BoundedData {rightAssociative=true}
TransitionLBounded ::= (TransitionRExpr|BaseData) spacing TRANSITION_SEP_L spacing BoundedData {rightAssociative=true}
TransitionRBounded ::= BaseData spacing TRANSITION_SEP_R spacing BoundedData {rightAssociative=true}
/*
Pair ::= (BaseData|TransitionL|TransitionR) spacing PAIR_SEP spacing (BaseData|Pair|TransitionL|TransitionR){rightAssociative=true} // default pair. sectiona: x = y sectionb: asdf
PairBounded ::= (BaseData|TransitionL|TransitionR) spacing PAIR_SEP spacing BoundedData{rightAssociative=true} // pair that may end in properties. (x = y = section: lol)
// A -> B <- A -> B =
TransitionL ::= (BaseData|TransitionR) spacing TRANSITION_SEP_L spacing (BaseData|TransitionL|TransitionR){rightAssociative=true}
TransitionLBounded ::= (BaseData|TransitionR) spacing TRANSITION_SEP_L spacing (Properties|TransitionLBounded|TransitionRBounded|BaseData){rightAssociative=true}
TransitionR ::= BaseData spacing TRANSITION_SEP_R spacing (BaseData|TransitionR){rightAssociative=true}
TransitionRBounded ::= BaseData spacing TRANSITION_SEP_R spacing (Properties|TransitionRBounded|BaseData){rightAssociative=true}
*/


//BoundedData ::= Properties|PairBounded|TransitionLBounded|TransitionRBounded|BaseData // data that is surrounded by bounds

// all these items that can be contained in a path and have incipient and terminator chars.
containedSegment ::= REGEX|LITERAL|List|Map|Precedence
// asdf10&3/4 vs "asdf"10 & 3/4"asdf"
// spacing items
spacing ::= (WHITESPACE|COMMENT)*