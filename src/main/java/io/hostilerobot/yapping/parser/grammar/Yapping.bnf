//
{
    parserClass="io.hostilerobot.yapping.parser.YappingParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="Yapping"
    psiImplClassSuffix="Impl"
    psiPackage="io.hostilerobot.yapping.parser.psi"
    psiImplPackage="io.hostilerobot.yapping.parser.psi.impl"

    elementTypeHolderClass="io.hostilerobot.yapping.parser.YappingTypes"
    elementTypeClass="io.hostilerobot.yapping.token.YappingElementType"
    tokenTypeClass="io.hostilerobot.yapping.token.YappingTokenType"
}

/*
SIGN ::= PLUS|MINUS
INTEGER ::= SIGN? NATURAL
*/
yapping ::= item*
item ::= JPATH|FPATH|YSEGMENT|COMMENT|WHITESPACE
JPATH ::= JPATH_START spacing JSCOPE
FPATH ::= (FPATH_START spacing FSCOPE)

private JSCOPE ::= JSCOPE_SEGMENT spacing (DOT spacing JSCOPE)?
private FSCOPE ::= FSCOPE_SEGMENT spacing (SLASH spacing FSCOPE)?
private spacing ::= (WHITESPACE|COMMENT)*

// ::JSCOPE_SEGMENT::
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
private JSCOPE_SEGMENT ::= JSCOPE_START JSCOPE_BODY*

/// connect any number of paths using "asdf"+(123, 456).0+"abc"
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */
YSEGMENT ::= (NATURAL (YSEG_START YSEG_PART*)?)|(YNAME YSEG_PART*)|(YSEG_START YSEG_PART*)
private YSEG_START ::= LITERAL|REGEX
private YSEG_PART ::= (YBODY|NATURAL|LITERAL|REGEX)
// NATURAL -> LITERAL -> (ANY)
// @`asdf`( !`asdf`asdf( sadf`asdf` ) )
// keep a stack of items. `asdf`{ abc = ced, def = hij }"asdf"
// {k1 = 1, v1 = 2, v3 = {x = 3, y = 3, x = 2} }.{`[kv]1` = `\<2`, "v3" = {x = `\>=3` } }
//YSCOPE_SEGMENT ::= YINDEX_SEGMENT|YNAME_SEGMENT
//private NAT_ALLOWED ::= (YINDEX_SEGMENT|REGEX_EXPECTED)
//private YINDEX_SEGMENT ::= NATURAL REGEX_EXPECTED?
//private REGEX_EXPECTED ::= REGEX NAT_ALLOWED?
//
//private YNAME_SEGMENT ::= YNAME_START YNAME_BODY*
//private YNAME_START ::= (YNAME|YNAME_PART)
//private YNAME_BODY ::= (YBODY|YNAME_PART)
//private YNAME_PART ::= (REGEX|LITERAL)

// ::FSCOPE_SEGMENT::
// 0file.yap            "0file.yap"
// 0"fil/e".yap         "0fil/e.yap"
// 1`[a-z]+`.yap        "1delta.yap"
// 0`[1-9]`               05
// 0`[1-9]`5              015
// 0`[1-9]``[3-5]`        093
// 0 5                    <invalid>
private FSCOPE_SEGMENT ::= (REGEX|FNAME|LITERAL)+

private JSCOPE_START ::= (JNAME|JSCOPE_PART)  // JNAME cannot start with 0-9
private JSCOPE_BODY  ::= (JBODY|JSCOPE_PART)  // but JBODY can
private JSCOPE_PART ::= (REGEX|LITERAL)

/*

FRACTION ::= (SIGN? NATURAL)? SIGN? NATURAL FRACTION_SEP NATURAL
private PRIMITIVE ::= (DECIMAL|INTEGER|REGEX|NAME|LITERAL|FRACTION)
*/

/*
BASE_DATA ::= (LIST|PRIMITIVE)
SECTION_DATA ::= (BASE_DATA|CPROPERTIES|PAIR)
private LIST_DATA ::= (BASE_DATA|APROPERTIES|PAIR)
LIST ::= LIST_START LIST_END
    | LIST_START LIST_DATA (LIST_ITEM_SEP LIST_DATA)* LIST_END

SECTION_KEY ::=
    (BASE_DATA|CPROPERTIES) SCOPE|LIST|JSCOPE_SEGMENT
SECTION_BODY ::= SECTION_DATA*

MPROPERTIES ::= (SECTION_KEY PROPERTIES_SEP SECTION_BODY)+
APROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_SEP?
CPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP
LPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP? // left is required
RPROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_END // right is required
SCOPE ::= DOT (JSCOPE_SEGMENT | INDEX_RESOLUTION)\
*/
// want: an arbitrary expression that evaluates to a list or an environment
// what thing are possible?
// (MAP).scope
// properties.scope
// :properties;.scope
// properties;.scope
// :properties.scope    -- does not work. must be right leaning
/*
private PAIR_KEY_DATA ::= (RPROPERTIES|BASE_DATA)
private PAIR_VAL_DATA ::= LIST_DATA
PAIR ::= PAIR_KEY_DATA PAIR_SEP PAIR_VAL_DATA

MAP ::= MAP_START

        MAP_END

 */
// section:
//    NAME|(...)



//    // whitespace, bad char
//    public static final IElementType WHITE_SPACE = TokenType.WHITE_SPACE;
//    public static final IElementType BAD_CHARACTER = TokenType.BAD_CHARACTER;
//
//    // comments
//    public static final IElementType COMMENT = new YappingElementType("COMMENT");
//    // primitives
//    public static final IElementType DECIMAL = new YappingElementType("DECIMAL");  // has the form \d+.\d+
//    public static final IElementType INTEGER = new YappingElementType("INTEGER");  // has the form \d+
//    public static final IElementType REGEX = new YappingElementType("REGEX");      // has the form `regex~flags`
//    public static final IElementType NAME = new YappingElementType("NAME");        // has the form \w+
//    public static final IElementType LITERAL = new YappingElementType("LITERAL");  // has the form "[^"]*"
//    public static final IElementType FRACTION = new YappingElementType("FRACTION");// has the form INTEGER / INTEGER
//
//    // sections
//    public static final IElementType SECTION_START = new YappingElementType("SECTION_START"); // : in :name
//    public static final IElementType SECTION_SEP = new YappingElementType("SECTION_SEP");     // : in name:
//    public static final IElementType SECTION_END = new YappingElementType("SECTION_END");         // ;
//
//    // lists
//    public static final IElementType LIST_START = new YappingElementType("LIST_START"); // (
//    public static final IElementType LIST_ITEM = new YappingElementType("LIST_ITEM");   // ,
//    public static final IElementType LIST_END = new YappingElementType("LIST_END");     // )
//
//    // maps
//    public static final IElementType MAP_START = new YappingElementType("MAP_START"); // {
//    public static final IElementType MAP_SEP = new YappingElementType("MAP_SEP");     // =
//    public static final IElementType MAP_ITEM = new YappingElementType("MAP_ITEM");   // ,
//    public static final IElementType MAP_END = new YappingElementType("MAP_END");     // }
//
//    // pairs
//    public static final IElementType PAIR_SEP = new YappingElementType("PAIR_SEP");   // =
//
//    // scopes and lookups
//    public static final IElementType SCOPE = new YappingElementType("SCOPE");               // "."
//    public static final IElementType LOOKUP_BEGIN = new YappingElementType("LOOKUP_BEGIN"); // "["
//    public static final IElementType LOOKUP_END = new YappingElementType("LOOKUP_END");     // "]"
//
//    // paths. File path preceded by "!" and uses "/" as a separator
//    //        Java path preceded by "@" and uses "." as a separator
//    public static final IElementType FILE_PATH = new YappingElementType("FILE_PATH");
//    public static final IElementType JAVA_PATH = new YappingElementType("JAVA_PATH");