//
{
    parserClass="io.hostilerobot.yapping.parser.YappingParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="Yapping"
    psiImplClassSuffix="Impl"
    psiPackage="io.hostilerobot.yapping.parser.psi"
    psiImplPackage="io.hostilerobot.yapping.parser.psi.impl"

    elementTypeHolderClass="io.hostilerobot.yapping.parser.YappingTypes"
    elementTypeClass="io.hostilerobot.yapping.token.YappingElementType"
    tokenTypeClass="io.hostilerobot.yapping.token.YappingTokenType"
}

/**
 * yapping may have items that consist of a header, then a set of properties
 * # example
 *   headerItem
 *   headerItem2
 *   123
 *   properties:
 *   properties2:
 *  // goes to the end of file
 */
yapping ::= item* Properties? // properties ends the file
item ::=
    SectionData
    |COMMENT|WHITESPACE // whitespace

SectionData ::= Pair|TransitionL|TransitionR|BaseData

BaseData ::= Precedence // (x)
    |Map|List   // composite data
    |jPath|fPath|yPath1 // paths. final path is a two part or more yapping segment
    |ySegmentMulti  // single yapping segment (not a path)
    |REGEX|LITERAL|YNAME // primitive - string types
    |QUOTIENT|INTEGER|REAL  // primitive - numbers
// # Java Paths and Scopes
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
    jPath ::= (JPATH_START spacing jScope)
    private jScope ::= jScopeSegment (spacing DOT spacing jScope)?
    private jScopeSegment ::= (jSegmentSingle|jSegmentMulti)
    // single item in the segment
    private jSegmentSingle ::= JNAME | containedSegment
    // multiple items in the segment
    private jSegmentMulti ::= (JNAME jSegmentExclJBody)
        | (containedSegment jSegmentInclJBody)
    // jBody or jName cannot show up twice in a row
    private jSegmentExclJBody ::= containedSegment jSegmentInclJBody?
    private jSegmentInclJBody ::= (JBODY jSegmentExclJBody?)
        | jSegmentExclJBody

// # file paths and scopes
    fPath ::= (FPATH_START spacing fScope)
    private fScope ::= fScopeSegment (spacing SLASH spacing fScope)?
    private fScopeSegment ::= fSegmentSingle | fSegmentMulti
    private fSegmentSingle ::= FNAME | containedSegment
    private fSegmentMulti ::= (containedSegment fSegmentInclFName)
        | (FNAME fSegmentExclFName)
    private fSegmentExclFName ::= containedSegment fSegmentInclFName?
    private fSegmentInclFName ::= (FNAME fSegmentExclFName?)
        | fSegmentExclFName

// # yapping paths and scopes
    //yPath0 ::= yPath1|NATURAL|ySegmentExclNat // single a or a(.b)+
    yPath1 ::= ((NATURAL spacing DOT spacing ySegmentExclNat) (spacing DOT spacing yPathRest)?)
        | (ySegmentExclNat spacing DOT spacing yPathRest)

    // fun idea -- ipaddress: 127.0.0.1 693.5.9.3; -- note that 0.0 would represent a double otherwise
    private ySegmentExclNat ::= ySegmentMulti | YNAME | containedSegment // multi segments are not considered nats

    private yPathRest ::= (YNAME|NATURAL|containedSegment|ySegmentMulti) (spacing DOT spacing yPathRest)?
    private ySegmentMulti ::= (containedSegment ySegmentInclVals)
        | ((YNAME|NATURAL) ySegmentExclVals)

    // (55).`~*5` vs 55.`~*5`
    // x.0abc x.0`[1-3]` x.0"123"
    // NATURAL -> containedSegment
    // (yBody|yName) -> containedSegment
    // containedSegment -> YBODY|NATURAL|containedSegment
    private ySegmentExclVals ::= containedSegment ySegmentInclVals?
    private ySegmentInclVals ::= ((NATURAL|YBODY) ySegmentExclVals?)
        | ySegmentExclVals

    // disallow NATURAL.NATURAL
    // -1.0.123

// all these items that can be contained in a path and have incipient and terminator chars.
private containedSegment ::= REGEX|LITERAL|List|Map|Precedence
// asdf10&3/4 vs "asdf"10 & 3/4"asdf"
// spacing items
private spacing ::= (WHITESPACE|COMMENT)*

// possible -
/// connect any number of paths using "asdf"+(123, 456).0+"abc"
// current -
// connect paths by not having whitespace
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */

QUOTIENT ::= (INTEGER spacing) AND INTEGER spacing SLASH spacing NATURAL // 1 & 3/4, -1 &3/4, +1 & -3/4.
INTEGER ::= (SIGN spacing)? NATURAL
REAL ::= (SIGN spacing)? DECIMAL
DECIMAL ::= NATURAL DOT NATURAL // define DECIMAL in parser rather than lexer, as this might be part of a ysegment rather than a decimal
private SIGN ::= (PLUS|MINUS)

// properties is just
//     name1 : value1a value1b
//     name2 : value2a value2b value2c
// to nest properties, we use precedence
//     name1 : value1a value1b
//     (name2 : value2a value2b) value2c
Properties ::= (BaseData spacing PROPERTY_SEP item*)+

Map ::= (MAP_START spacing MAP_END) // {}
    // { a = b[, c = d]* }
    | (MAP_START spacing PairBounded (spacing LIST_SEP spacing PairBounded)* spacing MAP_END)
List ::= (LIST_START LIST_END) // []
    // [a[, b]*]
    | LIST_START spacing BoundedData (spacing LIST_SEP spacing BoundedData)* spacing LIST_END
Precedence ::= PRECEDENCE_START spacing BoundedData spacing PRECEDENCE_END

Pair ::= (BaseData|TransitionL|TransitionR) spacing PAIR_SEP spacing (BaseData|Pair|TransitionL|TransitionR){rightAssociative=true} // default pair. sectiona: x = y sectionb: asdf
PairBounded ::= (BaseData|TransitionL|TransitionR) spacing PAIR_SEP spacing BoundedData{rightAssociative=true} // pair that may end in properties. (x = y = section: lol)
// A -> B <- A -> B =
TransitionL ::= (BaseData|TransitionR) spacing TRANSITION_SEP_L spacing (BaseData|TransitionL|TransitionR){rightAssociative=true}
TransitionLBounded ::= (BaseData|TransitionR) spacing TRANSITION_SEP_L spacing (Properties|TransitionLBounded|TransitionRBounded|BaseData){rightAssociative=true}
TransitionR ::= BaseData spacing TRANSITION_SEP_R spacing (BaseData|TransitionR){rightAssociative=true}
TransitionRBounded ::= BaseData spacing TRANSITION_SEP_R spacing (Properties|TransitionRBounded|BaseData){rightAssociative=true}

BoundedData ::= Properties|PairBounded|TransitionLBounded|TransitionRBounded|BaseData // data that is surrounded by bounds