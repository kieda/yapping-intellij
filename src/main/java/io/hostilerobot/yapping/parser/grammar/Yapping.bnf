//
{
    parserClass="io.hostilerobot.yapping.parser.YappingParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="Yapping"
    psiImplClassSuffix="Impl"
    psiPackage="io.hostilerobot.yapping.parser.psi"
    psiImplPackage="io.hostilerobot.yapping.parser.psi.impl"

    elementTypeHolderClass="io.hostilerobot.yapping.parser.YappingTypes"
    elementTypeClass="io.hostilerobot.yapping.token.YappingElementType"
    tokenTypeClass="io.hostilerobot.yapping.token.YappingTokenType"
}

yapping ::= item*
item ::= jPathC|fPathC|YSCOPE|COMMENT|WHITESPACE // |REGEX|PRECEDENCE|MAP|LIST|JPATHC|YPATHC|FPATHC -- TODO PROPERTIES top level vs in a section

// # Java Paths and Scopes
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>

// todo - Do not allow properties in paths/segments/scopes
// ## centered scope segment
    // path where properties need to both have incipient ':' and terminator ';'
    jPathC ::= (JPATH_START spacing jScopeC)
    private jScopeC ::= jScopeSegmentC (spacing DOT spacing jScopeC)?
    private jScopeSegmentC ::= (jSegmentSingleC|jSegmentMultiC)
    // single item in the segment
    private jSegmentSingleC ::= JNAME | containedSegment | PROPERTIESC // allow properties, but only if it's the only item in the segment
    // multiple items in the segment
    private jSegmentMultiC ::= (JNAME jSegmentExclJBodyC)
        | (containedSegment jSegmentInclJBodyC)
    // jBody or jName cannot show up twice in a row
    private jSegmentExclJBodyC ::= containedSegment jSegmentInclJBodyC?
    private jSegmentInclJBodyC ::= (JBODY jSegmentExclJBodyC?)
        | jSegmentExclJBodyC
// ## left leaning java scope segment.
//    We require incipient ':' to indicate we are lexing a yapping properties name, and not a java path.
//    we only permit left leaning scope at the end of the path    (!asdf.:asdf: value;"end".:asdf: asfd.asf)
    jPathL ::= (JPATH_START spacing jScopeL)
    private jScopeL ::= PROPERTIESL // single item - left leaning properties (!:asdf: value).
        | PROPERTIESC               // single item - centered properties (!:asdf: value;).
        | jScopePathL               // path - potentially ending in left leaning properties
    private jScopePathL ::= jScopeSegmentC spacing DOT spacing jScopePathL // otherwise scope segment
        | jEndSegmentL // end of the path/last item
    private jEndSegmentL ::= PROPERTIESL // last item is propertiesL
        | jScopeSegmentC // path is equivalent to using jPathC

// # file paths and scopes
// ## centered file scope element
    fPathC ::= (FPATH_START spacing fScopeC)
    private fScopeC ::= fScopeSegmentC (spacing SLASH spacing fScopeC)?
    private fScopeSegmentC ::= fSegmentSingleC | fSegmentMultiC
    private fSegmentSingleC ::= FNAME | containedSegment | PROPERTIESC
    private fSegmentMultiC ::= (containedSegment fSegmentInclFName)
        | (FNAME fSegmentExclFName)
    private fSegmentExclFName ::= containedSegment fSegmentInclFName?
    private fSegmentInclFName ::= (FNAME fSegmentExclFName?)
        | fSegmentExclFName
// ## left leaning file scope element
    fPathL ::= (FPATH_START spacing fScopeL)
    private fScopeL ::= PROPERTIESL
        | PROPERTIESC
        | fScopePathL
    // though we could relax rules on terminator ';' because '.' is more pervasive than '/'
    // it still introduces problems like (@:asdf: value 3 / 4) vs (@:asdf: value 3 / 4 / path) vs (@:asdf: 3 value / 4 / path)
    // this winds up too context-sensitive, so we just require terminator ';' if we want to end the properties in the current path
    private fScopePathL ::= fScopeSegmentC spacing SLASH spacing fScopePathL
        | fEndSegmentL
    private fEndSegmentL ::= PROPERTIESL
        | fScopeSegmentC

// # yapping paths and scopes
private YSCOPE ::= YSEGMENT (spacing DOT spacing YSCOPE)?
YSEGMENT ::= (NATURAL (YSEG_START YSEG_PART*)?)|(YNAME YSEG_PART*)|(YSEG_START YSEG_PART*)
private YSEG_START ::= LITERAL|REGEX
private YSEG_PART ::= (YBODY|NATURAL|LITERAL|REGEX)

// all these items that can be contained in a path and have incipient and terminator chars.
private containedSegment ::= REGEX|LITERAL|list|map|precedence
// spacing items
private spacing ::= (WHITESPACE|COMMENT)*

/// connect any number of paths using "asdf"+(123, 456).0+"abc"
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */

INTEGER ::= SIGN? NATURAL
REAL ::= (SIGN)? DECIMAL
private SIGN ::= (PLUS|MINUS)

map ::= MAP_START MAP_END
list ::= LIST_START LIST_END
precedence ::= PRECEDENCE_START PRECEDENCE_END



/*

FRACTION ::= (SIGN? NATURAL)? SIGN? NATURAL FRACTION_SEP NATURAL
private PRIMITIVE ::= (DECIMAL|INTEGER|REGEX|NAME|LITERAL|FRACTION)
*/

/*
BASE_DATA ::= (LIST|PRIMITIVE)
SECTION_DATA ::= (BASE_DATA|CPROPERTIES|PAIR)
private LIST_DATA ::= (BASE_DATA|APROPERTIES|PAIR)
LIST ::= LIST_START LIST_END
    | LIST_START LIST_DATA (LIST_ITEM_SEP LIST_DATA)* LIST_END

SECTION_KEY ::=
    (BASE_DATA|CPROPERTIES) SCOPE|LIST|JSCOPE_SEGMENT
SECTION_BODY ::= SECTION_DATA*

MPROPERTIES ::= (SECTION_KEY PROPERTIES_SEP SECTION_BODY)+
APROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_SEP?
CPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP
LPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP? // left is required
RPROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_END // right is required
SCOPE ::= DOT (JSCOPE_SEGMENT | INDEX_RESOLUTION)\
*/
// want: an arbitrary expression that evaluates to a list or an environment
// what thing are possible?
// (MAP).scope
// properties.scope
// :properties;.scope
// properties;.scope
// :properties.scope    -- does not work. must be right leaning
/*
private PAIR_KEY_DATA ::= (RPROPERTIES|BASE_DATA)
private PAIR_VAL_DATA ::= LIST_DATA
PAIR ::= PAIR_KEY_DATA PAIR_SEP PAIR_VAL_DATA

MAP ::= MAP_START

        MAP_END

 */
// section:
//    NAME|(...)



//    // whitespace, bad char
//    public static final IElementType WHITE_SPACE = TokenType.WHITE_SPACE;
//    public static final IElementType BAD_CHARACTER = TokenType.BAD_CHARACTER;
//
//    // comments
//    public static final IElementType COMMENT = new YappingElementType("COMMENT");
//    // primitives
//    public static final IElementType DECIMAL = new YappingElementType("DECIMAL");  // has the form \d+.\d+
//    public static final IElementType INTEGER = new YappingElementType("INTEGER");  // has the form \d+
//    public static final IElementType REGEX = new YappingElementType("REGEX");      // has the form `regex~flags`
//    public static final IElementType NAME = new YappingElementType("NAME");        // has the form \w+
//    public static final IElementType LITERAL = new YappingElementType("LITERAL");  // has the form "[^"]*"
//    public static final IElementType FRACTION = new YappingElementType("FRACTION");// has the form INTEGER / INTEGER
//
//    // sections
//    public static final IElementType SECTION_START = new YappingElementType("SECTION_START"); // : in :name
//    public static final IElementType SECTION_SEP = new YappingElementType("SECTION_SEP");     // : in name:
//    public static final IElementType SECTION_END = new YappingElementType("SECTION_END");         // ;
//
//    // lists
//    public static final IElementType LIST_START = new YappingElementType("LIST_START"); // (
//    public static final IElementType LIST_ITEM = new YappingElementType("LIST_ITEM");   // ,
//    public static final IElementType LIST_END = new YappingElementType("LIST_END");     // )
//
//    // maps
//    public static final IElementType MAP_START = new YappingElementType("MAP_START"); // {
//    public static final IElementType MAP_SEP = new YappingElementType("MAP_SEP");     // =
//    public static final IElementType MAP_ITEM = new YappingElementType("MAP_ITEM");   // ,
//    public static final IElementType MAP_END = new YappingElementType("MAP_END");     // }
//
//    // pairs
//    public static final IElementType PAIR_SEP = new YappingElementType("PAIR_SEP");   // =
//
//    // scopes and lookups
//    public static final IElementType SCOPE = new YappingElementType("SCOPE");               // "."
//    public static final IElementType LOOKUP_BEGIN = new YappingElementType("LOOKUP_BEGIN"); // "["
//    public static final IElementType LOOKUP_END = new YappingElementType("LOOKUP_END");     // "]"
//
//    // paths. File path preceded by "!" and uses "/" as a separator
//    //        Java path preceded by "@" and uses "." as a separator
//    public static final IElementType FILE_PATH = new YappingElementType("FILE_PATH");
//    public static final IElementType JAVA_PATH = new YappingElementType("JAVA_PATH");