//
{
    parserClass="io.hostilerobot.yapping.parser.YappingParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="Yapping"
    psiImplClassSuffix="Impl"
    psiPackage="io.hostilerobot.yapping.parser.psi"
    psiImplPackage="io.hostilerobot.yapping.parser.psi.impl"

    elementTypeHolderClass="io.hostilerobot.yapping.parser.YappingTypes"
    elementTypeClass="io.hostilerobot.yapping.token.YappingElementType"
    tokenTypeClass="io.hostilerobot.yapping.token.YappingTokenType"
}

yapping ::= item*
item ::=
    Pair|Precedence
    |jPath|fPath|yPath1 // paths. final one is two part yapping segment
    |ySegmentMulti // single yapping segment
    |COMMENT|WHITESPACE // whitespace
    |REGEX|LITERAL|YNAME // primitive - strings
    |INTEGER|DECIMAL|QUOTIENT // primitive - numbers
    |map|list|item|PropertiesC // composite data



    // |REGEX|PRECEDENCE|MAP|LIST|JPATHC|YPATHC|FPATHC -- TODO PROPERTIES top level vs in a section

// # Java Paths and Scopes
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
    jPath ::= (JPATH_START spacing jScope)
    private jScope ::= jScopeSegment (spacing DOT spacing jScope)?
    private jScopeSegment ::= (jSegmentSingle|jSegmentMulti)
    // single item in the segment
    private jSegmentSingle ::= JNAME | containedSegment
    // multiple items in the segment
    private jSegmentMulti ::= (JNAME jSegmentExclJBody)
        | (containedSegment jSegmentInclJBody)
    // jBody or jName cannot show up twice in a row
    private jSegmentExclJBody ::= containedSegment jSegmentInclJBody?
    private jSegmentInclJBody ::= (JBODY jSegmentExclJBody?)
        | jSegmentExclJBody

// # file paths and scopes
    fPath ::= (FPATH_START spacing fScope)
    private fScope ::= fScopeSegment (spacing SLASH spacing fScope)?
    private fScopeSegment ::= fSegmentSingle | fSegmentMulti
    private fSegmentSingle ::= FNAME | containedSegment
    private fSegmentMulti ::= (containedSegment fSegmentInclFName)
        | (FNAME fSegmentExclFName)
    private fSegmentExclFName ::= containedSegment fSegmentInclFName?
    private fSegmentInclFName ::= (FNAME fSegmentExclFName?)
        | fSegmentExclFName

// # yapping paths and scopes
    //yPath0 ::= yPath1|NATURAL|ySegmentExclNat // single a or a(.b)+
    yPath1 ::= ((NATURAL spacing DOT spacing ySegmentExclNat) (spacing DOT spacing yPathRest)?)
        | (ySegmentExclNat spacing DOT spacing yPathRest)

    // fun idea -- ipaddress: 127.0.0.1 693.5.9.3; -- note that 0.0 would represent a double otherwise
    private ySegmentExclNat ::= ySegmentMulti | YNAME | containedSegment // multi segments are not considered nats

    private yPathRest ::= (YNAME|NATURAL|containedSegment|ySegmentMulti) (spacing DOT spacing yPathRest)?
    private ySegmentMulti ::= (containedSegment ySegmentInclVals)
        | ((YNAME|NATURAL) ySegmentExclVals)

    // (55).`~*5` vs 55.`~*5`
    // x.0abc x.0`[1-3]` x.0"123"
    // NATURAL -> containedSegment
    // (yBody|yName) -> containedSegment
    // containedSegment -> YBODY|NATURAL|containedSegment
    private ySegmentExclVals ::= containedSegment ySegmentInclVals?
    private ySegmentInclVals ::= ((NATURAL|YBODY) ySegmentExclVals?)
        | ySegmentExclVals

    // disallow NATURAL.NATURAL
    // -1.0.123

// all these items that can be contained in a path and have incipient and terminator chars.
private containedSegment ::= REGEX|LITERAL|list|map|precedence
// spacing items
private spacing ::= (WHITESPACE|COMMENT)*

/// connect any number of paths using "asdf"+(123, 456).0+"abc"
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */

INTEGER ::= SIGN? NATURAL
REAL ::= (SIGN)? DECIMAL
DECIMAL ::= (SIGN)? spacing NATURAL DOT NATURAL // define DECIMAL in parser rather than lexer, as this might be part of a ysegment rather than a decimal
private SIGN ::= (PLUS|MINUS)

map ::= MAP_START MAP_END
list ::= LIST_START LIST_END
precedence ::= PRECEDENCE_START PRECEDENCE_END



/*

FRACTION ::= (SIGN? NATURAL)? SIGN? NATURAL FRACTION_SEP NATURAL
private PRIMITIVE ::= (DECIMAL|INTEGER|REGEX|NAME|LITERAL|FRACTION)
*/

/*
BASE_DATA ::= (LIST|PRIMITIVE)
SECTION_DATA ::= (BASE_DATA|CPROPERTIES|PAIR)
private LIST_DATA ::= (BASE_DATA|APROPERTIES|PAIR)
LIST ::= LIST_START LIST_END
    | LIST_START LIST_DATA (LIST_ITEM_SEP LIST_DATA)* LIST_END

SECTION_KEY ::=
    (BASE_DATA|CPROPERTIES) SCOPE|LIST|JSCOPE_SEGMENT
SECTION_BODY ::= SECTION_DATA*

MPROPERTIES ::= (SECTION_KEY PROPERTIES_SEP SECTION_BODY)+
APROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_SEP?
CPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP
LPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP? // left is required
RPROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_END // right is required
SCOPE ::= DOT (JSCOPE_SEGMENT | INDEX_RESOLUTION)\
*/
// want: an arbitrary expression that evaluates to a list or an environment
// what thing are possible?
// (MAP).scope
// properties.scope
// :properties;.scope
// properties;.scope
// :properties.scope    -- does not work. must be right leaning
/*
private PAIR_KEY_DATA ::= (RPROPERTIES|BASE_DATA)
private PAIR_VAL_DATA ::= LIST_DATA
PAIR ::= PAIR_KEY_DATA PAIR_SEP PAIR_VAL_DATA

MAP ::= MAP_START

        MAP_END

 */
// section:
//    NAME|(...)



//    // whitespace, bad char
//    public static final IElementType WHITE_SPACE = TokenType.WHITE_SPACE;
//    public static final IElementType BAD_CHARACTER = TokenType.BAD_CHARACTER;
//
//    // comments
//    public static final IElementType COMMENT = new YappingElementType("COMMENT");
//    // primitives
//    public static final IElementType DECIMAL = new YappingElementType("DECIMAL");  // has the form \d+.\d+
//    public static final IElementType INTEGER = new YappingElementType("INTEGER");  // has the form \d+
//    public static final IElementType REGEX = new YappingElementType("REGEX");      // has the form `regex~flags`
//    public static final IElementType NAME = new YappingElementType("NAME");        // has the form \w+
//    public static final IElementType LITERAL = new YappingElementType("LITERAL");  // has the form "[^"]*"
//    public static final IElementType FRACTION = new YappingElementType("FRACTION");// has the form INTEGER / INTEGER
//
//    // sections
//    public static final IElementType SECTION_START = new YappingElementType("SECTION_START"); // : in :name
//    public static final IElementType SECTION_SEP = new YappingElementType("SECTION_SEP");     // : in name:
//    public static final IElementType SECTION_END = new YappingElementType("SECTION_END");         // ;
//
//    // lists
//    public static final IElementType LIST_START = new YappingElementType("LIST_START"); // (
//    public static final IElementType LIST_ITEM = new YappingElementType("LIST_ITEM");   // ,
//    public static final IElementType LIST_END = new YappingElementType("LIST_END");     // )
//
//    // maps
//    public static final IElementType MAP_START = new YappingElementType("MAP_START"); // {
//    public static final IElementType MAP_SEP = new YappingElementType("MAP_SEP");     // =
//    public static final IElementType MAP_ITEM = new YappingElementType("MAP_ITEM");   // ,
//    public static final IElementType MAP_END = new YappingElementType("MAP_END");     // }
//
//    // pairs
//    public static final IElementType PAIR_SEP = new YappingElementType("PAIR_SEP");   // =
//
//    // scopes and lookups
//    public static final IElementType SCOPE = new YappingElementType("SCOPE");               // "."
//    public static final IElementType LOOKUP_BEGIN = new YappingElementType("LOOKUP_BEGIN"); // "["
//    public static final IElementType LOOKUP_END = new YappingElementType("LOOKUP_END");     // "]"
//
//    // paths. File path preceded by "!" and uses "/" as a separator
//    //        Java path preceded by "@" and uses "." as a separator
//    public static final IElementType FILE_PATH = new YappingElementType("FILE_PATH");
//    public static final IElementType JAVA_PATH = new YappingElementType("JAVA_PATH");