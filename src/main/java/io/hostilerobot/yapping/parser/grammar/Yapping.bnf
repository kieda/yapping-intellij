//
{
    parserClass="io.hostilerobot.yapping.parser.YappingParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="Yapping"
    psiImplClassSuffix="Impl"
    psiPackage="io.hostilerobot.yapping.parser.psi"
    psiImplPackage="io.hostilerobot.yapping.parser.psi.impl"

    elementTypeHolderClass="io.hostilerobot.yapping.parser.YappingTypes"
    elementTypeClass="io.hostilerobot.yapping.parser.token.YappingElementType"
    tokenTypeClass="io.hostilerobot.yapping.parser.token.YappingTokenType"
}


SIGN ::= PLUS|MINUS
INTEGER ::= SIGN? NATURAL

private JSCOPE_STR ::= (REGEX|NAME|LITERAL)

// note - we shouldn't permit spaces or comments in between
//        parts of the resolutions
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
JSCOPE_SEGMENT ::= JSCOPE_STR (JSCOPE_STR|NATURAL)*

// 0file.yap            "0file.yap"
// 0"fil/e".yap         "0fil/e.yap"
// 1`[a-z]+`.yap        "1delta.yap"
FSCOPE_SEGMENT ::= (REGEX|FNAME|LITERAL)+

// 0`[1-9]`               05
// 0`[1-9]`5              015
// 0`[1-9]``[3-5]`        093
// 0 5                    <invalid>
private EMPTY ::= ()
private NAT_ALLOWED ::= (NATURAL REGEX_EXPECTED|REGEX NAT_ALLOWED|EMPTY)
private REGEX_EXPECTED ::= (REGEX NAT_ALLOWED|EMPTY)
INDEX_RESOLUTION ::= NATURAL REGEX_EXPECTED

FRACTION ::= (SIGN? NATURAL)? SIGN? NATURAL FRACTION_SEP NATURAL
private PRIMITIVE ::= (DECIMAL|INTEGER|REGEX|NAME|LITERAL|FRACTION)

// todo - should these scopes be done during lexing?
private JSCOPE ::= JSCOPE_SEGMENT (DOT JSCOPE)?
JPATH ::= JPATH_START JSCOPE
private FSCOPE ::= FSCOPE_SEGMENT (SLASH FSCOPE)?
FPATH ::= FPATH_START FSCOPE

BASE_DATA ::= (LIST|PRIMITIVE)
SECTION_DATA ::= (BASE_DATA|CPROPERTIES|PAIR)
private LIST_DATA ::= (BASE_DATA|APROPERTIES|PAIR)
LIST ::= LIST_START LIST_END
    | LIST_START LIST_DATA (LIST_ITEM_SEP LIST_DATA)* LIST_END

SECTION_KEY ::=
    (BASE_DATA|CPROPERTIES) SCOPE|LIST|JSCOPE_SEGMENT
SECTION_BODY ::= SECTION_DATA*

MPROPERTIES ::= (SECTION_KEY PROPERTIES_SEP SECTION_BODY)+
APROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_SEP?
CPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP
LPROPERTIES ::= PROPERTIES_SEP MPROPERTIES PROPERTIES_SEP? // left is required
RPROPERTIES ::= PROPERTIES_SEP? MPROPERTIES PROPERTIES_END // right is required
SCOPE ::= DOT (JSCOPE_SEGMENT | INDEX_RESOLUTION)\

// want: an arbitrary expression that evaluates to a list or an environment
// what thing are possible?
// (MAP).scope
// properties.scope
// :properties;.scope
// properties;.scope
// :properties.scope    -- does not work. must be right leaning

private PAIR_KEY_DATA ::= (RPROPERTIES|BASE_DATA)
private PAIR_VAL_DATA ::= LIST_DATA
PAIR ::= PAIR_KEY_DATA PAIR_SEP PAIR_VAL_DATA

MAP ::= MAP_START

        MAP_END
// section:
//    NAME|(...)



//    // whitespace, bad char
//    public static final IElementType WHITE_SPACE = TokenType.WHITE_SPACE;
//    public static final IElementType BAD_CHARACTER = TokenType.BAD_CHARACTER;
//
//    // comments
//    public static final IElementType COMMENT = new YappingElementType("COMMENT");
//    // primitives
//    public static final IElementType DECIMAL = new YappingElementType("DECIMAL");  // has the form \d+.\d+
//    public static final IElementType INTEGER = new YappingElementType("INTEGER");  // has the form \d+
//    public static final IElementType REGEX = new YappingElementType("REGEX");      // has the form `regex~flags`
//    public static final IElementType NAME = new YappingElementType("NAME");        // has the form \w+
//    public static final IElementType LITERAL = new YappingElementType("LITERAL");  // has the form "[^"]*"
//    public static final IElementType FRACTION = new YappingElementType("FRACTION");// has the form INTEGER / INTEGER
//
//    // sections
//    public static final IElementType SECTION_START = new YappingElementType("SECTION_START"); // : in :name
//    public static final IElementType SECTION_SEP = new YappingElementType("SECTION_SEP");     // : in name:
//    public static final IElementType SECTION_END = new YappingElementType("SECTION_END");         // ;
//
//    // lists
//    public static final IElementType LIST_START = new YappingElementType("LIST_START"); // (
//    public static final IElementType LIST_ITEM = new YappingElementType("LIST_ITEM");   // ,
//    public static final IElementType LIST_END = new YappingElementType("LIST_END");     // )
//
//    // maps
//    public static final IElementType MAP_START = new YappingElementType("MAP_START"); // {
//    public static final IElementType MAP_SEP = new YappingElementType("MAP_SEP");     // =
//    public static final IElementType MAP_ITEM = new YappingElementType("MAP_ITEM");   // ,
//    public static final IElementType MAP_END = new YappingElementType("MAP_END");     // }
//
//    // pairs
//    public static final IElementType PAIR_SEP = new YappingElementType("PAIR_SEP");   // =
//
//    // scopes and lookups
//    public static final IElementType SCOPE = new YappingElementType("SCOPE");               // "."
//    public static final IElementType LOOKUP_BEGIN = new YappingElementType("LOOKUP_BEGIN"); // "["
//    public static final IElementType LOOKUP_END = new YappingElementType("LOOKUP_END");     // "]"
//
//    // paths. File path preceded by "!" and uses "/" as a separator
//    //        Java path preceded by "@" and uses "." as a separator
//    public static final IElementType FILE_PATH = new YappingElementType("FILE_PATH");
//    public static final IElementType JAVA_PATH = new YappingElementType("JAVA_PATH");